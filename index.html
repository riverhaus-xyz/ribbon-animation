<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ribbon Animation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #F0EEE6;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="ribbonCanvas"></canvas>
    
    <script>
        // === CONFIGURATION OPTIONS - MODIFY HERE ===
        const config = {
            // Solution 1: Color of lines and dots (default: dark gray)
            ribbonColor: '#404040',
            
            // Solution 2: Background color (default: beige)
            backgroundColor: '#F0EEE6',
            
            // Solution 3: Transparent background (default: false)
            transparentBackground: false
        };
        // ============================================
        
        // Canvas setup
        const canvas = document.getElementById('ribbonCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas dimensions
        canvas.width = 550;
        canvas.height = 550;
        
        // Ribbon segment interface
        class RibbonSegment {
            constructor(x, y, angle, width, height, depth) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.width = width;
                this.height = height;
                this.depth = depth;
            }
        }
        
        // Ribbon strip class
        class RibbonStrip {
            constructor() {
                this.segments = [];
                this.segmentCount = 30;
                this.width = 100;
                this.initialize();
            }
            
            initialize() {
                for (let i = 0; i < this.segmentCount; i++) {
                    this.segments.push(new RibbonSegment(
                        0,
                        0,
                        0,
                        this.width,
                        20,
                        0
                    ));
                }
            }
            
            update(time) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                for (let i = 0; i < this.segments.length; i++) {
                    const t = i / (this.segments.length - 1);
                    const segment = this.segments[i];
                    
                    const smoothTime = time * 0.25;
                    const baseAngle = t * Math.PI * 6 + smoothTime;
                    const foldPhase = Math.sin(smoothTime * 0.01 + t * Math.PI * 4);
                    const heightPhase = Math.cos(smoothTime * 0.00375 + t * Math.PI * 3);
                    
                    const radius = 120 + foldPhase * 60;
                    segment.x = centerX + Math.cos(baseAngle) * radius;
                    segment.y = centerY + Math.sin(baseAngle) * radius + heightPhase * 30;
                    
                    segment.angle = baseAngle + foldPhase * Math.PI * 0.5;
                    segment.width = this.width * (1 + foldPhase * 0.3);
                    segment.depth = Math.sin(baseAngle + time * 0.15);
                }
            }
            
            draw(ribbonColor) {
                ctx.lineWidth = 1.5;
                ctx.setLineDash([2, 2]);
                
                const sortedSegments = [...this.segments].sort((a, b) => {
                    const threshold = 0.1;
                    return Math.abs(a.depth - b.depth) > threshold ? a.depth - b.depth : 0;
                });
                
                for (let i = 0; i < sortedSegments.length - 1; i++) {
                    const current = sortedSegments[i];
                    const next = sortedSegments[i + 1];
                    
                    ctx.save();
                    ctx.beginPath();
                    
                    const cos1 = Math.cos(current.angle);
                    const sin1 = Math.sin(current.angle);
                    const cos2 = Math.cos(next.angle);
                    const sin2 = Math.sin(next.angle);
                    
                    const p1 = {
                        x: current.x - sin1 * current.width/2,
                        y: current.y + cos1 * current.width/2
                    };
                    const p2 = {
                        x: current.x + sin1 * current.width/2,
                        y: current.y - cos1 * current.width/2
                    };
                    const p3 = {
                        x: next.x + sin2 * next.width/2,
                        y: next.y - cos2 * next.width/2
                    };
                    const p4 = {
                        x: next.x - sin2 * next.width/2,
                        y: next.y + cos2 * next.width/2
                    };
                    
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.closePath();
                    
                    const depthFactor = (current.depth + 1) * 0.5;
                    const opacity = 0.6 + depthFactor * 0.4;
                    
                    ctx.strokeStyle = `rgba(${hexToRgb(ribbonColor).r}, ${hexToRgb(ribbonColor).g}, ${hexToRgb(ribbonColor).b}, ${opacity})`;
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(p2.x, p2.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(current.x, current.y);
                    ctx.lineTo(next.x, next.y);
                    ctx.strokeStyle = `rgba(${hexToRgb(ribbonColor).r}, ${hexToRgb(ribbonColor).g}, ${hexToRgb(ribbonColor).b}, ${opacity * 0.7})`;
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                for (let i = 0; i < sortedSegments.length; i++) {
                    const segment = sortedSegments[i];
                    const cos = Math.cos(segment.angle);
                    const sin = Math.sin(segment.angle);
                    
                    const p1 = {
                        x: segment.x - sin * segment.width/2,
                        y: segment.y + cos * segment.width/2
                    };
                    const p2 = {
                        x: segment.x + sin * segment.width/2,
                        y: segment.y - cos * segment.width/2
                    };
                    
                    const depthFactor = (segment.depth + 1) * 0.5;
                    const opacity = 0.7 + depthFactor * 0.3;
                    
                    ctx.beginPath();
                    ctx.arc(p1.x, p1.y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${hexToRgb(ribbonColor).r}, ${hexToRgb(ribbonColor).g}, ${hexToRgb(ribbonColor).b}, ${opacity})`;
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(p2.x, p2.y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${hexToRgb(ribbonColor).r}, ${hexToRgb(ribbonColor).g}, ${hexToRgb(ribbonColor).b}, ${opacity})`;
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${hexToRgb(ribbonColor).r}, ${hexToRgb(ribbonColor).g}, ${hexToRgb(ribbonColor).b}, ${opacity})`;
                    ctx.fill();
                }
                
                ctx.setLineDash([]);
            }
        }
        
        // Helper function to convert hex color to RGB
        function hexToRgb(hex) {
            hex = hex.replace(/^#/, '');
            const bigint = parseInt(hex, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return { r, g, b };
        }
        
        // Animation setup
        const ribbon = new RibbonStrip();
        let time = 0;
        let animationFrameId;
        
        function animate() {
            if (!config.transparentBackground) {
                ctx.fillStyle = config.backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            
            time += 0.00125;
            ribbon.update(time);
            ribbon.draw(config.ribbonColor);
            
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // Start animation
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            // You might want to adjust canvas size on resize if needed
        });
    </script>
</body>
</html>
